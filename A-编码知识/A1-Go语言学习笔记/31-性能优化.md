# 31|性能优化

## 常见分析指标

Wall Time

CPU Time

Block TIme

Mermory alloction

GC times

## 常见性能优化方式

### json的序列化与反序列化

> Go语言原生的json解析框架使用了struct tag配合反射机制实现，简单易用，但是由于反射的性能很差，一般只在读配置文件这种低频场景下使用原生json解析。一般对于高频的json序列化/反序列化推荐使用easy-json(采用代码生成的方式，而并非反射)性能差距在30%-100%左右

### 字符串拼接

> 这里使用最常见的字符串拼接作为示例，代表是一类问题：不可变类型频繁的进行拼接等操作，造成大量的内存申请操作，影响性能的同时也会占用较大的内存空间，并且还会较为频繁的触发GC。推荐使用strings.builder进行优化性能提升在2-3倍，且内存开销差距巨大

上述两个问题的2合1优化代码（easyjson的使用可以参考前面的笔记）

```go
package profiling

import (
   "encoding/json"
   "strconv"
   "strings"
)

func createRequest() string {
   payload := make([]int, 100, 100)
   for i := 0; i < 100; i++ {
      payload[i] = i
   }
   req := Request{"demo_transaction", payload}
   v, err := json.Marshal(&req)
   if err != nil {
      panic(err)
   }
   return string(v)
}

func processRequestBest(reqs []string) []string {
   reps := []string{}
   for _, req := range reqs {
      reqObj := &Request{}
      reqObj.UnmarshalJSON([]byte(req))
      // json.Unmarshal([]byte(req), reqObj)

      var buf strings.Builder
      for _, e := range reqObj.PayLoad {
         buf.WriteString(strconv.Itoa(e))
         buf.WriteString(",")
      }
      repObj := &Response{reqObj.TransactionID, buf.String()}
      repJson, err := repObj.MarshalJSON()
      //repJson, err := json.Marshal(&repObj)
      if err != nil {
         panic(err)
      }
      reps = append(reps, string(repJson))
   }
   return reps
}

func processRequestOld(reqs []string) []string {
   reps := []string{}
   for _, req := range reqs {
      reqObj := &Request{}
      json.Unmarshal([]byte(req), reqObj)
      ret := ""
      for _, e := range reqObj.PayLoad {
         ret += strconv.Itoa(e) + ","
      }
      repObj := &Response{reqObj.TransactionID, ret}
      repJson, err := json.Marshal(&repObj)
      if err != nil {
         panic(err)
      }
      reps = append(reps, string(repJson))
   }
   return reps
}

func processRequestEasyJson(reqs []string) []string {
   reps := []string{}
   for _, req := range reqs {
      reqObj := &Request{}
      reqObj.UnmarshalJSON([]byte(req))
      ret := ""
      for _, e := range reqObj.PayLoad {
         ret += strconv.Itoa(e) + ","
      }
      repObj := &Response{reqObj.TransactionID, ret}
      repJson, err := json.Marshal(&repObj)
      if err != nil {
         panic(err)
      }
      reps = append(reps, string(repJson))
   }
   return reps
}
```

